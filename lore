#!/usr/bin/env python3
import usb.core
import usb.util
import argparse
import subprocess
import os
import sys
import requests
import json

# EdisonV3 USB constants
RELESE_VENDOR_ID = 0x16D0
RELESE_PRODUCT_ID = 0x1207

EV3_WEBUSB_HEADER = 0x58
EV3_WEBUSB_CMD_PUT_USER_PROGRAM = 0x14

# Remote API URL for compilation
REMOTE_COMPILE_API_URL = "https://api.edisonrobotics.net/ep/compile/ep_compile_usb_v3"

def transpile_logo_to_py(logo_file_path: str, py_file_path: str):
    """
    Transpiles a .logo file with basic LOGO commands to an EdPy .py file.
    """
    print(f"Transpiling {logo_file_path} to {py_file_path}...")
    
    edpy_code = [
        "import Ed",
        "",
        "# Standard EdPy setup",
        "Ed.EdisonVersion = Ed.V3",
        "Ed.DistanceUnits = Ed.CM",
        "Ed.Tempo = Ed.TEMPO_MEDIUM",
        ""
    ]

    with open(logo_file_path, 'r') as f:
        for line in f:
            line = line.strip().upper()
            if not line:
                continue

            parts = line.split()
            command = parts[0]
            
            try:
                if command == "FORWARD" and len(parts) == 2:
                    value = int(parts[1])
                    edpy_code.append(f"Ed.Drive(Ed.FORWARD, Ed.SPEED_5, {value})")
                elif command == "BACK" and len(parts) == 2:
                    value = int(parts[1])
                    edpy_code.append(f"Ed.Drive(Ed.BACKWARD, Ed.SPEED_5, {value})")
                elif command == "LEFT" and len(parts) == 2:
                    value = int(parts[1])
                    edpy_code.append(f"Ed.Drive(Ed.SPIN_LEFT, Ed.SPEED_5, {value})")
                elif command == "RIGHT" and len(parts) == 2:
                    value = int(parts[1])
                    edpy_code.append(f"Ed.Drive(Ed.SPIN_RIGHT, Ed.SPEED_5, {value})")
                else:
                    print(f"Warning: Unsupported LOGO command '{line}' found. Skipping.", file=sys.stderr)
            except (ValueError, IndexError):
                print(f"Warning: Invalid format for LOGO command '{line}'. Skipping.", file=sys.stderr)

    with open(py_file_path, 'w') as f:
        f.write("\n".join(edpy_code))
    
    print("Transpilation successful.")


def process_api_hex_string(input_hex_str):
    """
    Converts a hexadecimal string into a bytearray,
    matching the logic of the web app's processAPIHexString function.
    """
    prog_size = len(input_hex_str) // 2
    user_prog_data = bytearray(prog_size)
    
    for i in range(0, len(input_hex_str), 2):
        num_string = "0x" + input_hex_str[i:i+2]
        num_data = int(num_string, 16)
        user_prog_data[i // 2] = num_data
        
    if prog_size > 2048:
        print("Warning: Program size exceeds 2048 bytes. This might cause issues on the device.", file=sys.stderr)
    
    return user_prog_data

def calculate_checksum(data: bytearray) -> int:
    """
    Calculates the 16-bit XOR checksum based on the web app's logic.
    """
    checksum = 0
    lower_byte = True
    for byte_val in data:
        if lower_byte:
            checksum ^= byte_val
            lower_byte = False
        else:
            checksum ^= (byte_val << 8)
            lower_byte = True
    return checksum & 0xFFFF

def find_edison_v3():
    """Finds the Edison V3 device."""
    print("Attempting to find Edison V3 device...")
    dev = usb.core.find(idVendor=RELESE_VENDOR_ID, idProduct=RELESE_PRODUCT_ID)
    if dev is None:
        raise ValueError("Edison V3 not found. Is it connected and powered on?")
    print(f"Edison V3 device found: {dev}")
    return dev

def setup_device(dev):
    """Configures the USB device for communication."""
    print("Setting configuration...")
    try:
        dev.set_configuration()
        print("Configuration set.")
    except usb.core.USBError as e:
        if "Access denied" in str(e):
            print("Error: Access denied to USB device. You might need to run this script with sudo or ensure appropriate udev rules are in place.", file=sys.stderr)
            sys.exit(1)
        raise

    print("Checking and detaching kernel drivers...")
    for cfg in dev:
        for intf in cfg:
            if dev.is_kernel_driver_active(intf.bInterfaceNumber):
                try:
                    print(f"Detaching kernel driver from interface {intf.bInterfaceNumber}...")
                    dev.detach_kernel_driver(intf.bInterfaceNumber)
                    print(f"Kernel driver detached from interface {intf.bInterfaceNumber}.")
                except usb.core.USBError as e:
                    print(f"Could not detach kernel driver from interface {intf.bInterfaceNumber}: {e}", file=sys.stderr)
    
    print("Claiming interface 0...")
    usb.util.claim_interface(dev, 0)
    print("Interface 0 claimed.")
    
    return dev

def transfer_out(dev, endpoint_address, data):
    """Performs a USB bulk transfer out."""
    print(f"Transferring {len(data)} bytes OUT to endpoint {hex(endpoint_address)}...")
    bytes_sent = dev.write(endpoint_address, data)
    print(f"Sent {bytes_sent} bytes OUT.")
    return bytes_sent

def transfer_in(dev, endpoint_address, length):
    """Performs a USB bulk transfer in."""
    print(f"Transferring {length} bytes IN from endpoint {hex(endpoint_address)}...")
    received_data = dev.read(endpoint_address, length)
    print(f"Received {len(received_data)} bytes IN.")
    return received_data

def put_user_program(dev, user_program_data: bytearray):
    """Sends the user program to the Edison V3."""
    size = len(user_program_data)
    checksum = calculate_checksum(user_program_data)

    header = bytearray([
        EV3_WEBUSB_HEADER,
        EV3_WEBUSB_CMD_PUT_USER_PROGRAM,
        size & 0xFF, (size >> 8) & 0xFF,
        checksum & 0xFF, (checksum >> 8) & 0xFF,
        0, 0
    ])

    print("Sending program header...")
    transfer_out(dev, 0x01, header)
    response = transfer_in(dev, 0x81, 8)
    if not (len(response) == 8 and response[0] == EV3_WEBUSB_HEADER and response[1] == EV3_WEBUSB_CMD_PUT_USER_PROGRAM):
        raise IOError(f"Invalid response to program header: {response.tobytes().hex()}")
    
    print("Sending program data...")
    transfer_out(dev, 0x01, user_program_data)
    response = transfer_in(dev, 0x81, 8)
    if not (len(response) == 8 and response[0] == EV3_WEBUSB_HEADER and response[1] == EV3_WEBUSB_CMD_PUT_USER_PROGRAM and response[2] == 1):
        raise IOError(f"Program transfer failed with response: {response.tobytes().hex()}")
    
    print("Program transferred successfully!")

def build_mpy_cross(mpy_cross_path: str):
    """Builds the mpy-cross executable if it doesn't exist."""
    if not os.path.exists(mpy_cross_path):
        print("mpy-cross not found, attempting to build it using 'make'...")
        try:
            subprocess.run(["make"], check=True)
            print("'make' completed successfully. mpy-cross should now be available.")
        except (subprocess.CalledProcessError, FileNotFoundError) as e:
            raise RuntimeError(f"Error: 'make' failed or was not found. Please build mpy-cross manually.", e)

def compile_remotely(py_file_path: str, output_mpy_file: str):
    """
    Compiles a Python file using the remote Edison API and saves the resulting .mpy bytecode.
    """
    try:
        with open(py_file_path, 'r') as f:
            python_code = f.read()
        
        print(f"Sending {py_file_path} to remote compiler API...")
        response = requests.post(REMOTE_COMPILE_API_URL, data=python_code, headers={'Content-Type': 'text/plain'})
        response.raise_for_status()
        
        json_response = response.json()
        
        if json_response.get("error") or not json_response.get("compile", True):
            error_message = "Unknown remote compilation error."
            nested_message = json_response.get("message")
            if nested_message:
                try:
                    nested_json = json.loads(nested_message)
                    if nested_json.get("error") and nested_json.get("messages"):
                        error_message = "; ".join(nested_json["messages"])
                except json.JSONDecodeError:
                    error_message = nested_message
            raise RuntimeError(f"Remote compilation error: {error_message}")
        
        hex_data = json_response.get("hex")
        if not hex_data:
            raise RuntimeError("Remote compiler did not return 'hex' data.")
            
        compiled_bytes = bytes.fromhex(hex_data)
        
        with open(output_mpy_file, 'wb') as f:
            f.write(compiled_bytes)
            
        print(f"Remote compilation successful. Saved to {output_mpy_file}")
        
    except requests.exceptions.RequestException as e:
        raise RuntimeError(f"Failed to connect to remote compiler API: {e}")
    except ValueError as e:
        raise RuntimeError(f"Error processing remote compiler response: {e}")

def compile_app(app_name: str, mpy_cross_path: str, use_local_compiler: bool) -> str:
    """
    Detects if an app is LOGO or Python, transpiles if needed, then compiles to .mpy.
    """
    app_dir = os.path.join("apps", app_name)
    py_file_path = os.path.join(app_dir, "main.py")
    logo_file_path = os.path.join(app_dir, "main.logo")

    if os.path.exists(logo_file_path):
        transpile_logo_to_py(logo_file_path, py_file_path)
    elif not os.path.exists(py_file_path):
        raise FileNotFoundError(f"Application source file not found: checked for main.py and main.logo in {app_dir}")
    
    output_mpy_file = os.path.join(app_dir, "main.mpy")

    if use_local_compiler:
        build_mpy_cross(mpy_cross_path)
        print(f"Compiling {py_file_path} to {output_mpy_file} using local {mpy_cross_path}...")
        try:
            subprocess.run([mpy_cross_path, "-o", output_mpy_file, py_file_path], check=True)
            print("Local compilation successful.")
        except subprocess.CalledProcessError as e:
            raise RuntimeError(f"Local mpy-cross compilation failed: {e}")
    else:
        compile_remotely(py_file_path, output_mpy_file)

    return output_mpy_file

def flash_app(mpy_file_path: str):
    """
    Flashes a pre-compiled .mpy file to the Edison V3.
    """
    if not os.path.exists(mpy_file_path):
        raise FileNotFoundError(f"Compiled MicroPython file not found: {mpy_file_path}. Please build it first.")

    with open(mpy_file_path, 'rb') as f:
        mpy_bytes = f.read()
    
    mpy_hex_string = mpy_bytes.hex()
    program_data_to_send = process_api_hex_string(mpy_hex_string)

    print("Starting Edison V3 device flashing process.")
    dev = find_edison_v3()
    print("Device found. Proceeding with setup.")
    setup_device(dev)
    
    try:
        print("Attempting to put user program...")
        put_user_program(dev, program_data_to_send)
        print("Program flashed to Edison V3 successfully!")
    finally:
        print("Flashing process finished. Releasing resources.")
        try:
            print("Releasing interface 0...")
            usb.util.release_interface(dev, 0)
            print("Interface 0 released.")
        except usb.core.USBError as e:
            print(f"Warning: Could not release interface 0: {e}", file=sys.stderr)
        
        try:
            print("Attempting to re-attach kernel driver...")
            dev.attach_kernel_driver(0)
            print("Kernel driver re-attached.")
        except usb.core.USBError as e:
            if "No such device" not in str(e):
                print(f"Warning: Could not re-attach kernel driver: {e}", file=sys.stderr)
            else:
                print("Kernel driver attachment skipped (device not found, possibly disconnected).")
        
        print("Disposing USB resources.")
        usb.util.dispose_resources(dev)
        print("USB resources disposed.")

def main():
    parser = argparse.ArgumentParser(description="Lore: Edison V3 MicroPython CLI Tool for offline development.")
    parser.add_argument("--mpy-cross", 
                        default="./micropython-1.27.0/mpy-cross/build/mpy-cross",
                        help="Path to the mpy-cross executable.")
    
    subparsers = parser.add_subparsers(dest="command", help="Available commands")

    build_parser = subparsers.add_parser("build", help="Compile a MicroPython or LOGO application.")
    build_parser.add_argument("app_name", help="Name of the application to compile.")
    build_parser.add_argument("--local-compile", action="store_true", 
                              help="Use the local mpy-cross compiler (experimental).")

    flash_parser = subparsers.add_parser("flash", help="Flash a compiled application to the Edison V3.")
    flash_parser.add_argument("app_name", help="Name of the application to flash.")

    args = parser.parse_args()

    if args.command is None:
        parser.print_help()
        sys.exit(1)

    try:
        if args.command == "build" and not args.local_compile:
            try:
                import requests
                import json
            except ImportError:
                raise RuntimeError("The 'requests' library is required. Please run: pip install requests")

        if args.command == "build":
            compile_app(args.app_name, args.mpy_cross, args.local_compile)
            print(f"Application '{args.app_name}' built successfully.")
        elif args.command == "flash":
            # Note: flash always uses the pre-built .mpy file, it doesn't trigger a build.
            mpy_file = os.path.join("apps", args.app_name, "main.mpy")
            if not os.path.exists(mpy_file):
                print(f"'{mpy_file}' not found. Building application first...")
                compile_app(args.app_name, args.mpy_cross, False) # Defaults to remote compile for build-on-flash
            
            flash_app(mpy_file)
            print(f"Application '{args.app_name}' flashed successfully.")
    except Exception as e:
        print(f"Error: {e}", file=sys.stderr)
        sys.exit(1)

if __name__ == "__main__":
    if sys.version_info < (3, 8):
        print("Python 3.8 or newer is required.", file=sys.stderr)
        sys.exit(1)
    main()