#!/usr/bin/env python3
import usb.core
import usb.util
import argparse
import ast
import re
import subprocess
import os
import sys
import requests
import json
from lark import Lark, Token, Tree

# EdisonV3 USB constants
RELESE_VENDOR_ID = 0x16D0
RELESE_PRODUCT_ID = 0x1207

EV3_WEBUSB_HEADER = 0x58
EV3_WEBUSB_CMD_PUT_USER_PROGRAM = 0x14

# Remote API URL for compilation
REMOTE_COMPILE_API_URL = "https://api.edisonrobotics.net/ep/compile/ep_compile_usb_v3"

class LogoToEdPyTranspiler:
    """Transpiles a LOGO parse tree (from Lark) to EdPy MicroPython code."""

    def __init__(self, tree):
        self.tree = tree
        self.functions = {}  # name -> (param_names, body_statements)
        self._loop_counter = 0
        self._collect_functions(tree)

    @staticmethod
    def _tokens(node, token_type):
        """Get child tokens of a specific type."""
        return [c for c in node.children if isinstance(c, Token) and c.type == token_type]

    @staticmethod
    def _subtrees(node):
        """Get child Tree nodes."""
        return [c for c in node.children if isinstance(c, Tree)]

    def _collect_functions(self, tree):
        """First pass: collect function definitions with their parameters."""
        for stmt in tree.children:
            node = stmt.children[0]
            if node.data == "funcdef":
                name = str(self._tokens(node, "NAME")[0]).upper()
                params = [str(p)[1:].lower() for p in self._tokens(node, "PARAM")]
                body = self._subtrees(node)
                self.functions[name] = (params, body)

    def generate(self):
        """Generate EdPy Python code from the parse tree."""
        lines = [
            "import Ed",
            "",
            "# Standard EdPy setup",
            "Ed.EdisonVersion = Ed.V3",
            "Ed.DistanceUnits = Ed.CM",
            "Ed.Tempo = Ed.TEMPO_MEDIUM",
            ""
        ]
        # Emit function definitions
        for name, (params, body) in self.functions.items():
            param_str = ", ".join(params)
            lines.append(f"def {name.lower()}({param_str}):")
            for stmt in body:
                lines.extend(self._process_node(stmt.children[0], 1))
            lines.append("")
        # Emit main body
        for stmt in self.tree.children:
            node = stmt.children[0]
            if node.data != "funcdef":
                lines.extend(self._process_node(node, 0))
        return "\n".join(lines)

    def _process_expr(self, node):
        """Process an expression node (Token or Tree) into a Python expression string."""
        if isinstance(node, Token):
            if node.type == "NUMBER":
                return str(int(node))
            elif node.type == "PARAM":
                return str(node)[1:].lower()
        if node.data == "add":
            return f"({self._process_expr(node.children[0])} + {self._process_expr(node.children[1])})"
        elif node.data == "sub":
            return f"({self._process_expr(node.children[0])} - {self._process_expr(node.children[1])})"
        elif node.data == "mul":
            return f"({self._process_expr(node.children[0])} * {self._process_expr(node.children[1])})"
        elif node.data == "div":
            return f"({self._process_expr(node.children[0])} // {self._process_expr(node.children[1])})"
        elif node.data == "thing":
            return str(self._tokens(node, "QNAME")[0])[1:].lower()
        elif node.data == "readkeypad":
            return "Ed.ReadKeypad()"
        elif node.data == "readobstacle":
            return "Ed.ReadObstacleDetection()"
        elif node.data == "readclap":
            return "Ed.ReadClapSensor()"
        elif node.data == "readline":
            return "Ed.ReadLineState()"
        elif node.data == "readleftlight":
            return "Ed.ReadLeftLightLevel()"
        elif node.data == "readrightlight":
            return "Ed.ReadRightLightLevel()"
        elif node.data == "readdistance":
            return "Ed.ReadDistance(Ed.MOTOR_LEFT)"
        return str(node)

    def _process_node(self, node, indent_level):
        """Recursively process a single AST node into code lines."""
        indent = "    " * indent_level
        data = node.data

        if data == "forward":
            expr = self._process_expr(node.children[1])
            return [indent + f"Ed.Drive(Ed.FORWARD, Ed.SPEED_5, {expr})"]
        elif data == "back":
            expr = self._process_expr(node.children[1])
            return [indent + f"Ed.Drive(Ed.BACKWARD, Ed.SPEED_5, {expr})"]
        elif data == "left":
            expr = self._process_expr(node.children[1])
            return [indent + f"Ed.Drive(Ed.SPIN_LEFT, Ed.SPEED_5, {expr})"]
        elif data == "right":
            expr = self._process_expr(node.children[1])
            return [indent + f"Ed.Drive(Ed.SPIN_RIGHT, Ed.SPEED_5, {expr})"]
        elif data == "repeat":
            count = self._process_expr(node.children[1])
            var = f"i{self._loop_counter}"
            self._loop_counter += 1
            lines = [indent + f"for {var} in range({count}):"]
            for child_stmt in self._subtrees(node):
                lines.extend(self._process_node(child_stmt.children[0], indent_level + 1))
            return lines
        elif data == "ifstmt":
            comp = self._subtrees(node)[0]  # comparison node
            left = self._process_expr(comp.children[0])
            op = str(self._tokens(comp, "COMP_OP")[0])
            if op == "=":
                op = "=="
            right = self._process_expr(comp.children[2])
            lines = [indent + f"if {left} {op} {right}:"]
            for child_stmt in self._subtrees(node)[1:]:
                lines.extend(self._process_node(child_stmt.children[0], indent_level + 1))
            return lines
        elif data == "ifelsestmt":
            subtrees = self._subtrees(node)
            comp = subtrees[0]  # comparison node
            left = self._process_expr(comp.children[0])
            op = str(self._tokens(comp, "COMP_OP")[0])
            if op == "=":
                op = "=="
            right = self._process_expr(comp.children[2])
            true_branch = [s for s in subtrees if s.data == "truebranch"][0]
            false_branch = [s for s in subtrees if s.data == "falsebranch"][0]
            lines = [indent + f"if {left} {op} {right}:"]
            for child_stmt in self._subtrees(true_branch):
                lines.extend(self._process_node(child_stmt.children[0], indent_level + 1))
            lines.append(indent + "else:")
            for child_stmt in self._subtrees(false_branch):
                lines.extend(self._process_node(child_stmt.children[0], indent_level + 1))
            return lines
        elif data == "make":
            varname = str(self._tokens(node, "QNAME")[0])[1:].lower()
            # The expr is the last non-keyword child
            expr_children = [c for c in node.children if not (isinstance(c, Token) and c.type in ("MAKE", "QNAME"))]
            expr = self._process_expr(expr_children[0])
            return [indent + f"{varname} = {expr}"]
        elif data == "ledon":
            return [indent + "Ed.LeftLed(Ed.ON)", indent + "Ed.RightLed(Ed.ON)"]
        elif data == "ledoff":
            return [indent + "Ed.LeftLed(Ed.OFF)", indent + "Ed.RightLed(Ed.OFF)"]
        elif data == "leftledon":
            return [indent + "Ed.LeftLed(Ed.ON)"]
        elif data == "leftledoff":
            return [indent + "Ed.LeftLed(Ed.OFF)"]
        elif data == "rightledon":
            return [indent + "Ed.RightLed(Ed.ON)"]
        elif data == "rightledoff":
            return [indent + "Ed.RightLed(Ed.OFF)"]
        elif data == "beep":
            return [indent + "Ed.PlayBeep()"]
        elif data == "playtone":
            note = self._process_expr(node.children[1])
            duration = self._process_expr(node.children[2])
            return [indent + f"Ed.PlayTone({note}, {duration})"]
        elif data == "wait":
            expr = self._process_expr(node.children[1])
            return [indent + f"Ed.TimeWait({expr}, Ed.TIME_SECONDS)"]
        elif data == "waitms":
            expr = self._process_expr(node.children[1])
            return [indent + f"Ed.TimeWait({expr}, Ed.TIME_MILLISECONDS)"]
        elif data == "stop":
            return [indent + "Ed.Drive(Ed.STOP, 1, 1)"]
        elif data == "forever":
            lines = [indent + "while True:"]
            for child_stmt in self._subtrees(node):
                lines.extend(self._process_node(child_stmt.children[0], indent_level + 1))
            return lines
        elif data == "whilestmt":
            comp = self._subtrees(node)[0]  # comparison node
            left = self._process_expr(comp.children[0])
            op = str(self._tokens(comp, "COMP_OP")[0])
            if op == "=":
                op = "=="
            right = self._process_expr(comp.children[2])
            lines = [indent + f"while {left} {op} {right}:"]
            for child_stmt in self._subtrees(node)[1:]:
                lines.extend(self._process_node(child_stmt.children[0], indent_level + 1))
            return lines
        elif data == "obstaclebeamon":
            return [indent + "Ed.ObstacleDetectionBeam(Ed.ON)"]
        elif data == "obstaclebeamoff":
            return [indent + "Ed.ObstacleDetectionBeam(Ed.OFF)"]
        elif data == "linetrackeron":
            return [indent + "Ed.LineTrackerLed(Ed.ON)"]
        elif data == "linetrackeroff":
            return [indent + "Ed.LineTrackerLed(Ed.OFF)"]
        elif data == "resetdistance":
            return [indent + "Ed.ResetDistance()"]
        elif data == "funccall":
            name = str(self._tokens(node, "NAME")[0]).upper()
            if name not in self.functions:
                raise RuntimeError(f"Unknown function '{name}'")

            # Build argument list from expr children
            expr_children = [c for c in node.children if not (isinstance(c, Token) and c.type == "NAME")]
            args = [self._process_expr(e) for e in expr_children]
            args_str = ", ".join(args)
            return [indent + f"{name.lower()}({args_str})"]
        else:
            raise RuntimeError(f"Unsupported LOGO command '{data}'")


def transpile_logo_to_py(logo_file_path: str, py_file_path: str):
    """
    Transpiles a .logo file to an EdPy .py file using a Lark grammar parser.
    """
    print(f"Transpiling {logo_file_path} to {py_file_path}...")

    grammar_path = os.path.join(os.path.dirname(os.path.abspath(__file__)), "logo.lark")
    with open(grammar_path, 'r') as f:
        grammar = f.read()
    with open(logo_file_path, 'r') as f:
        source = f.read()

    parser = Lark(grammar, parser="lalr")
    tree = parser.parse(source)

    transpiler = LogoToEdPyTranspiler(tree)
    code = transpiler.generate()

    with open(py_file_path, 'w') as f:
        f.write(code)

    print("Transpilation successful.")


def process_api_hex_string(input_hex_str):
    """
    Converts a hexadecimal string into a bytearray.
    """
    prog_size = len(input_hex_str) // 2
    user_prog_data = bytearray(prog_size)
    
    for i in range(0, len(input_hex_str), 2):
        num_string = "0x" + input_hex_str[i:i+2]
        num_data = int(num_string, 16)
        user_prog_data[i // 2] = num_data
        
    if prog_size > 2048:
        print("Warning: Program size exceeds 2048 bytes.", file=sys.stderr)
    
    return user_prog_data

def calculate_checksum(data: bytearray) -> int:
    """
    Calculates the 16-bit XOR checksum.
    """
    checksum = 0
    lower_byte = True
    for byte_val in data:
        if lower_byte:
            checksum ^= byte_val
            lower_byte = False
        else:
            checksum ^= (byte_val << 8)
            lower_byte = True
    return checksum & 0xFFFF

def find_edison_v3():
    """Finds the Edison V3 device."""
    dev = usb.core.find(idVendor=RELESE_VENDOR_ID, idProduct=RELESE_PRODUCT_ID)
    if dev is None:
        raise ValueError("Edison V3 not found.")
    return dev

def setup_device(dev):
    """Configures the USB device for communication."""
    try:
        dev.set_configuration()
    except usb.core.USBError as e:
        if "Access denied" in str(e):
            print("Error: Access denied to USB device. Try with sudo.", file=sys.stderr)
            sys.exit(1)
        # This error is often harmless, e.g., if already configured.
        print(f"Ignoring error during set_configuration: {e}", file=sys.stderr)

    # set_configuration() can cause the device to re-enumerate, making the
    # current device handle stale. We MUST release it and get a new one.
    usb.util.dispose_resources(dev)
    import time
    time.sleep(1.5) # Give the OS time to settle.
    dev = find_edison_v3()

    # Now, with a fresh handle, we can safely detach the kernel driver.
    try:
        if dev.is_kernel_driver_active(0):
            print("Detaching kernel driver...")
            dev.detach_kernel_driver(0)
    except usb.core.USBError as e:
        print(f"Warning: Could not detach kernel driver: {e}", file=sys.stderr)
    
    usb.util.claim_interface(dev, 0)
    return dev

def transfer_out(dev, endpoint_address, data):
    """Performs a USB bulk transfer out."""
    return dev.write(endpoint_address, data)

def transfer_in(dev, endpoint_address, length):
    """Performs a USB bulk transfer in."""
    return dev.read(endpoint_address, length)

def put_user_program(dev, user_program_data: bytearray):
    """Sends the user program to the Edison V3."""
    size = len(user_program_data)
    checksum = calculate_checksum(user_program_data)

    header = bytearray([
        EV3_WEBUSB_HEADER,
        EV3_WEBUSB_CMD_PUT_USER_PROGRAM,
        size & 0xFF, (size >> 8) & 0xFF,
        checksum & 0xFF, (checksum >> 8) & 0xFF,
        0, 0
    ])

    transfer_out(dev, 0x01, header)
    response = transfer_in(dev, 0x81, 8)
    if not (len(response) == 8 and response[0] == EV3_WEBUSB_HEADER and response[1] == EV3_WEBUSB_CMD_PUT_USER_PROGRAM):
        raise IOError(f"Invalid response to program header: {response.tobytes().hex()}")
    
    transfer_out(dev, 0x01, user_program_data)
    response = transfer_in(dev, 0x81, 8)
    if not (len(response) == 8 and response[0] == EV3_WEBUSB_HEADER and response[1] == EV3_WEBUSB_CMD_PUT_USER_PROGRAM and response[2] == 1):
        raise IOError(f"Program transfer failed with response: {response.tobytes().hex()}")
    
    print("Program transferred successfully!")

class EdPyValidator(ast.NodeVisitor):
    """Validates that a Python AST only uses features supported by EdPy."""

    def __init__(self, filename="main.py"):
        self.filename = filename
        self.errors = []

    def _error(self, node, msg):
        self.errors.append(f"{self.filename}:{node.lineno}: {msg}")

    def _inside_tunestring(self, node):
        """Check if node is an argument to Ed.TuneString()."""
        parent = getattr(node, '_parent', None)
        if not isinstance(parent, ast.Call):
            return False
        func = parent.func
        return (isinstance(func, ast.Attribute) and func.attr == "TuneString"
                and isinstance(func.value, ast.Name) and func.value.id == "Ed")

    def visit_Constant(self, node):
        if isinstance(node.value, float):
            self._error(node, f"constant {node.value} must be an integer value")
        elif isinstance(node.value, (str, bytes)):
            if not self._inside_tunestring(node):
                self._error(node, "string not allowed here")
        self.generic_visit(node)

    def visit_List(self, node):
        self._error(node, "list not allowed here")
        self.generic_visit(node)

    def visit_Dict(self, node):
        self._error(node, "dict expr not supported in Ed.Py")
        self.generic_visit(node)

    def visit_Tuple(self, node):
        self._error(node, "tuple expr not supported in Ed.Py")
        self.generic_visit(node)

    def visit_Set(self, node):
        self._error(node, "set expr not supported in Ed.Py")
        self.generic_visit(node)

    def visit_Import(self, node):
        for alias in node.names:
            if alias.name != "Ed":
                self._error(node, f"only the Ed module can be imported")
        self.generic_visit(node)

    def visit_ImportFrom(self, node):
        self._error(node, "only the Ed module can be imported")
        self.generic_visit(node)

    def visit_Try(self, node):
        self._error(node, "try/except not supported in Ed.Py")
        self.generic_visit(node)

    # Python 3.11+
    def visit_TryStar(self, node):
        self._error(node, "try/except not supported in Ed.Py")
        self.generic_visit(node)

    def visit_ClassDef(self, node):
        self._error(node, "classes not supported in Ed.Py")
        self.generic_visit(node)


def _set_parents(node):
    """Set _parent attribute on all AST nodes for parent lookup."""
    for child in ast.walk(node):
        for child_node in ast.iter_child_nodes(child):
            child_node._parent = child


def validate_edpy(py_file_path: str):
    """Validates a Python file against EdPy restrictions. Returns list of error strings."""
    with open(py_file_path, 'r') as f:
        source = f.read()
    try:
        tree = ast.parse(source, filename=py_file_path)
    except SyntaxError:
        return []  # mpy-cross will catch syntax errors
    _set_parents(tree)
    validator = EdPyValidator(filename="main.py")
    validator.visit(tree)
    return validator.errors


# Edison constant values, reverse-engineered from the remote compiler.
# The remote compiler inlines Ed.CONSTANT references as integer literals.
EDISON_CONSTANTS = {
    "V1": 1, "V2": 2, "V3": 3,
    "CM": 0, "INCH": 1,
    "FORWARD": 1, "BACKWARD": 2, "SPIN_LEFT": 8, "SPIN_RIGHT": 7, "STOP": 0,
    "SPEED_1": 1, "SPEED_2": 2, "SPEED_3": 3, "SPEED_4": 4, "SPEED_5": 5,
    "SPEED_6": 6, "SPEED_7": 7, "SPEED_8": 8, "SPEED_9": 9, "SPEED_10": 10,
    "ON": 1, "OFF": 0,
    "TEMPO_VERY_SLOW": 60, "TEMPO_SLOW": 92, "TEMPO_MEDIUM": 125,
    "TEMPO_FAST": 162, "TEMPO_VERY_FAST": 200,
    "TIME_SECONDS": 0, "TIME_MILLISECONDS": 1,
    "KEYPAD_ROUND": 4, "KEYPAD_TRIANGLE": 1, "KEYPAD_NONE": 0,
    "OBSTACLE_AHEAD": 16, "OBSTACLE_LEFT": 32, "OBSTACLE_RIGHT": 8, "OBSTACLE_NONE": 0,
    "LINE_ON_BLACK": 1, "LINE_ON_WHITE": 0,
    "CLAP_NOT_DETECTED": 0, "CLAP_DETECTED": 4,
    "DISTANCE_UNLIMITED": 1073741823,
    "MOTOR_LEFT": 0, "MOTOR_RIGHT": 1,
    "SPEED_FULL": 0,
}


def inline_ed_constants(py_file_path: str, output_path: str):
    """Reads a .py file, replaces Ed.CONSTANT references with integer values.
    Uses regex substitution to preserve original source structure (comments,
    blank lines, line numbers) so the bytecode line number table matches."""
    with open(py_file_path, 'r') as f:
        source = f.read()
    for name, value in EDISON_CONSTANTS.items():
        source = re.sub(r'\bEd\.' + name + r'\b', str(value), source)
    with open(output_path, 'w') as f:
        f.write(source)
    return output_path


# Edison firmware qstr mapping: name -> Edison static qstr ID.
# The Edison firmware has a completely different qstr table from standard
# MicroPython. Reverse-engineered by probing the remote compiler API.
EDISON_QSTR_IDS = {
    # Special qstrs
    "":                     1,
    "<module>":             7,
    # Edison API names (methods/properties on Ed module)
    "DistanceUnits":        10,
    "Drive":                11,
    "DriveLeftMotor":       12,
    "DriveRightMotor":      13,
    "Ed":                   14,
    "EdisonVersion":        15,
    "LeftLed":              17,
    "LineTrackerLed":       18,
    "ObstacleDetectionBeam": 20,
    "PlayBeep":             21,
    "PlayTone":             23,
    "PlayTune":             24,
    "ReadClapSensor":       28,
    "ReadDistance":          30,
    "ReadIRData":           32,
    "ReadKeypad":           33,
    "ReadLeftLightLevel":   34,
    "ReadLineState":        35,
    "ReadLineTracker":      36,
    "ReadMusicEnd":         37,
    "ReadObstacleDetection": 38,
    "ReadRemote":           39,
    "ReadRightLightLevel":  40,
    "ResetDistance":         43,
    "RightLed":             44,
    "SendIRData":           45,
    "Tempo":                48,
    "TimeWait":             49,
    "TuneString":           50,
    # Standard Python builtins/names (remapped IDs in Edison firmware)
    "abs": 101, "all": 102, "any": 103, "append": 104, "args": 105,
    "bool": 106, "bytearray": 108, "bytes": 110, "callable": 111,
    "chr": 112, "classmethod": 113, "clear": 114, "close": 115,
    "copy": 117, "count": 118, "dict": 119, "dir": 120, "divmod": 121,
    "end": 122, "endswith": 123, "eval": 124, "extend": 126,
    "find": 127, "format": 128, "get": 130, "getattr": 131,
    "globals": 132, "hasattr": 133, "hash": 134, "id": 135,
    "index": 136, "insert": 137, "int": 138, "isalpha": 139,
    "isdigit": 140, "isinstance": 141, "islower": 142,
    "issubclass": 144, "isupper": 145, "items": 146, "iter": 147,
    "join": 148, "key": 149, "keys": 150, "len": 151, "list": 152,
    "locals": 154, "lower": 155, "lstrip": 156, "map": 158,
    "next": 160, "object": 161, "open": 162, "ord": 163, "pop": 164,
    "pow": 166, "range": 168, "read": 169, "remove": 172,
    "replace": 173, "round": 178, "rstrip": 180, "self": 181,
    "send": 182, "set": 184, "setattr": 185, "sort": 187,
    "sorted": 188, "split": 189, "start": 190, "startswith": 191,
    "staticmethod": 192, "step": 193, "stop": 194, "str": 195,
    "strip": 196, "sum": 197, "super": 198, "throw": 199,
    "tuple": 201, "type": 202, "update": 203, "upper": 204,
    "value": 206, "values": 207, "write": 208, "zip": 209,
}

# Standard MicroPython static qstr ID -> string name.
# mpy-cross encodes these as compact static references in .mpy files.
# Since the Edison firmware has a completely different qstr table, we must
# convert any standard static qstr that isn't in EDISON_QSTR_IDS to dynamic
# (embedded string) form so the firmware can resolve it by name.
# Generated from micropython-1.27.0/mpy-cross/build/genhdr/qstrdefs.generated.h
STANDARD_QSTR_STRINGS = {
    0: "", 1: "", 2: "__dir__", 3: "\x0a", 4: " ", 5: "*", 6: "/",
    7: "<module>", 8: "_", 9: "__call__", 10: "__class__", 11: "__delitem__",
    12: "__enter__", 13: "__exit__", 14: "__getattr__", 15: "__getitem__",
    16: "__hash__", 17: "__init__", 18: "__int__", 19: "__iter__",
    20: "__len__", 21: "__main__", 22: "__module__", 23: "__name__",
    24: "__new__", 25: "__next__", 26: "__qualname__", 27: "__repr__",
    28: "__setitem__", 29: "__str__", 30: "ArithmeticError",
    31: "AssertionError", 32: "AttributeError", 33: "BaseException",
    34: "EOFError", 35: "Ellipsis", 36: "Exception", 37: "GeneratorExit",
    38: "ImportError", 39: "IndentationError", 40: "IndexError",
    41: "KeyError", 42: "KeyboardInterrupt", 43: "LookupError",
    44: "MemoryError", 45: "NameError", 46: "NoneType",
    47: "NotImplementedError", 48: "OSError", 49: "OverflowError",
    50: "RuntimeError", 51: "StopIteration", 52: "SyntaxError",
    53: "SystemExit", 54: "TypeError", 55: "ValueError",
    56: "ZeroDivisionError", 57: "abs", 58: "all", 59: "any",
    60: "append", 61: "args", 62: "bool", 63: "builtins", 64: "bytearray",
    65: "bytecode", 66: "bytes", 67: "callable", 68: "chr",
    69: "classmethod", 70: "clear", 71: "close", 72: "const", 73: "copy",
    74: "count", 75: "dict", 76: "dir", 77: "divmod", 78: "end",
    79: "endswith", 80: "eval", 81: "exec", 82: "extend", 83: "find",
    84: "format", 85: "from_bytes", 86: "get", 87: "getattr", 88: "globals",
    89: "hasattr", 90: "hash", 91: "id", 92: "index", 93: "insert",
    94: "int", 95: "isalpha", 96: "isdigit", 97: "isinstance",
    98: "islower", 99: "isspace", 100: "issubclass", 101: "isupper",
    102: "items", 103: "iter", 104: "join", 105: "key", 106: "keys",
    107: "len", 108: "list", 109: "little", 110: "locals", 111: "lower",
    112: "lstrip", 113: "main", 114: "map", 115: "micropython", 116: "next",
    117: "object", 118: "open", 119: "ord", 120: "pop", 121: "popitem",
    122: "pow", 123: "print", 124: "range", 125: "read", 126: "readinto",
    127: "readline", 128: "remove", 129: "replace", 130: "repr",
    131: "reverse", 132: "rfind", 133: "rindex", 134: "round",
    135: "rsplit", 136: "rstrip", 137: "self", 138: "send", 139: "sep",
    140: "set", 141: "setattr", 142: "setdefault", 143: "sort",
    144: "sorted", 145: "split", 146: "start", 147: "startswith",
    148: "staticmethod", 149: "step", 150: "stop", 151: "str", 152: "strip",
    153: "sum", 154: "super", 155: "throw", 156: "to_bytes", 157: "tuple",
    158: "type", 159: "update", 160: "upper", 161: "utf-8", 162: "value",
    163: "values", 164: "write", 165: "zip", 166: "<dictcomp>",
    167: "<genexpr>", 168: "<lambda>", 169: "<listcomp>", 170: "<setcomp>",
    171: "__add__", 172: "__bool__", 173: "__complex__", 174: "__contains__",
    175: "__eq__", 176: "__float__", 177: "__ge__", 178: "__gt__",
    179: "__iadd__", 180: "__isub__", 181: "__le__", 182: "__lt__",
    183: "__ne__", 184: "__sub__",
}

# Lookup: string name -> Edison static qstr ID (same as EDISON_QSTR_IDS, minus empty string)
_EDISON_NAME_TO_QSTR = {k: v for k, v in EDISON_QSTR_IDS.items() if k}


def _read_varint(data, offset):
    """Read a variable-length unsigned integer from bytes. Returns (value, new_offset)."""
    result = 0
    while True:
        b = data[offset]
        offset += 1
        result = (result << 7) | (b & 0x7F)
        if not (b & 0x80):
            return result, offset


def _encode_varint(value):
    """Encode an unsigned integer as a variable-length byte sequence."""
    if value == 0:
        return bytes([0])
    parts = []
    while value:
        parts.append(value & 0x7F)
        value >>= 7
    parts.reverse()
    result = bytes([b | 0x80 for b in parts[:-1]] + [parts[-1]])
    return result


def rewrite_mpy_qstrs(mpy_data):
    """
    Post-process an .mpy file to rewrite its qstr table for Edison firmware.

    The Edison firmware has a different qstr table from standard MicroPython.
    This function performs two transformations:

    1. Dynamic qstrs that match Edison API names → Edison static qstr IDs
       (e.g., "Ed" → static ID 14, "Drive" → static ID 11)

    2. Standard static qstrs whose ID differs between standard and Edison
       → remapped to Edison static qstr ID
       (e.g., standard "count" at ID 74 → Edison ID for "count")
    """
    if len(mpy_data) < 4 or mpy_data[0] != ord('M'):
        raise ValueError("Not a valid .mpy file")

    header = mpy_data[:4]
    offset = 4

    n_qstr, offset = _read_varint(mpy_data, offset)
    n_obj, offset = _read_varint(mpy_data, offset)

    new_qstr_data = bytearray()
    remapped = 0
    for i in range(n_qstr):
        val, new_offset = _read_varint(mpy_data, offset)
        if val & 1:
            # Standard static qstr reference
            std_id = val >> 1
            std_name = STANDARD_QSTR_STRINGS.get(std_id, "")
            if std_name in _EDISON_NAME_TO_QSTR:
                # Remap to Edison's ID for this string
                edison_id = _EDISON_NAME_TO_QSTR[std_name]
                new_qstr_data.extend(_encode_varint((edison_id << 1) | 1))
                if edison_id != std_id:
                    remapped += 1
            else:
                # Keep as-is (same ID in both tables, or unused in Edison)
                new_qstr_data.extend(_encode_varint(val))
            offset = new_offset
        else:
            # Dynamic qstr: val>>1 is string length
            str_len = val >> 1
            string_bytes = mpy_data[new_offset:new_offset + str_len]
            offset = new_offset + str_len + 1  # +1 for NUL

            name = string_bytes.decode('utf-8')
            if name in _EDISON_NAME_TO_QSTR:
                # Rewrite as Edison static qstr reference
                edison_id = _EDISON_NAME_TO_QSTR[name]
                new_qstr_data.extend(_encode_varint((edison_id << 1) | 1))
                remapped += 1
            else:
                # Keep as dynamic
                new_qstr_data.extend(_encode_varint(val))
                new_qstr_data.extend(string_bytes)
                new_qstr_data.append(0)

    result = bytearray(header)
    result.extend(_encode_varint(n_qstr))
    result.extend(_encode_varint(n_obj))
    result.extend(new_qstr_data)
    result.extend(mpy_data[offset:])

    if remapped:
        print(f"Remapped {remapped} qstr(s) to Edison firmware IDs.")

    return bytes(result)


def build_mpy_cross(mpy_cross_path: str):
    """Builds the mpy-cross executable if it doesn't exist."""
    if not os.path.exists(mpy_cross_path):
        print("mpy-cross not found, building with 'make'...")
        try:
            subprocess.run(["make"], check=True)
            print("'make' completed successfully.")
        except (subprocess.CalledProcessError, FileNotFoundError) as e:
            raise RuntimeError(f"Error: 'make' failed.", e)

def compile_remotely(py_file_path: str, output_mpy_file: str):
    """
    Compiles a Python file using the remote Edison API.
    """
    try:
        with open(py_file_path, 'r') as f:
            python_code = f.read()
        
        print(f"Sending to remote compiler API...")
        response = requests.post(REMOTE_COMPILE_API_URL, data=python_code, headers={'Content-Type': 'text/plain'})
        response.raise_for_status()
        
        json_response = response.json()
        
        if json_response.get("error") or not json_response.get("compile", True):
            error_message = "Unknown remote compilation error."
            nested_message = json_response.get("message")
            if nested_message:
                try:
                    nested_json = json.loads(nested_message)
                    if nested_json.get("error") and nested_json.get("messages"):
                        error_message = "; ".join(nested_json["messages"])
                except json.JSONDecodeError:
                    error_message = nested_message
            raise RuntimeError(f"Remote compilation error: {error_message}")
        
        hex_data = json_response.get("hex")
        if not hex_data:
            raise RuntimeError("Remote compiler did not return 'hex' data.")
            
        compiled_bytes = bytes.fromhex(hex_data)
        
        with open(output_mpy_file, 'wb') as f:
            f.write(compiled_bytes)
            
        print(f"Remote compilation successful.")
        
    except requests.exceptions.RequestException as e:
        raise RuntimeError(f"Failed to connect to remote compiler API: {e}")
    except ValueError as e:
        raise RuntimeError(f"Error processing remote compiler response: {e}")

def compile_app(app_name: str, mpy_cross_path: str, use_local_compiler: bool) -> str:
    """
    Detects if an app is LOGO or Python, transpiles if needed, then compiles to .mpy.
    """
    app_dir = os.path.join("apps", app_name)
    py_file_path = os.path.join(app_dir, "main.py")
    logo_file_path = os.path.join(app_dir, "main.logo")

    if os.path.exists(logo_file_path):
        transpile_logo_to_py(logo_file_path, py_file_path)
    elif not os.path.exists(py_file_path):
        raise FileNotFoundError(f"Application source not found in {app_dir}")
    
    output_mpy_file = os.path.join(app_dir, "main.mpy")

    if use_local_compiler:
        edpy_errors = validate_edpy(py_file_path)
        if edpy_errors:
            raise RuntimeError(f"EdPy validation failed:\n" + "\n".join(edpy_errors))
        build_mpy_cross(mpy_cross_path)
        # Pre-process: inline Ed.CONSTANT values to match remote compiler
        preprocessed_file = os.path.join(app_dir, "main.preprocessed.py")
        inline_ed_constants(py_file_path, preprocessed_file)
        print(f"Compiling with local {mpy_cross_path}...")
        result = subprocess.run(
            [mpy_cross_path, "-s", "", "-o", output_mpy_file, preprocessed_file],
            capture_output=True, text=True
        )
        os.remove(preprocessed_file)
        if result.returncode != 0:
            raise RuntimeError(f"Local compilation failed:\n{result.stderr.strip()}")
        # Post-process: remap qstrs to Edison firmware IDs
        with open(output_mpy_file, 'rb') as f:
            mpy_data = f.read()
        rewritten = rewrite_mpy_qstrs(mpy_data)
        with open(output_mpy_file, 'wb') as f:
            f.write(rewritten)
        print("Local compilation successful.")
    else:
        compile_remotely(py_file_path, output_mpy_file)

    return output_mpy_file

def flash_app(mpy_file_path: str):
    """
    Flashes a pre-compiled .mpy file to the Edison V3.
    """
    if not os.path.exists(mpy_file_path):
        raise FileNotFoundError(f"Compiled file not found: {mpy_file_path}. Please build first.")

    with open(mpy_file_path, 'rb') as f:
        mpy_bytes = f.read()
    
    program_data_to_send = process_api_hex_string(mpy_bytes.hex())

    dev = None
    try:
        dev = find_edison_v3()
        try:
            print("Edison V3 found, resetting...")
            dev.reset()
            import time
            time.sleep(1.5)
            dev = find_edison_v3()
            print("Edison V3 re-acquired after reset.")
        except usb.core.USBError as e:
            print(f"USB reset failed: {e}. Re-finding device...", file=sys.stderr)
            dev = find_edison_v3()
            
        dev = setup_device(dev)
        put_user_program(dev, program_data_to_send)

    finally:
        if dev is not None:
            try:
                usb.util.release_interface(dev, 0)
            except usb.core.USBError:
                # This can fail if the device has already disconnected, which is fine.
                pass
            try:
                # Re-attaching the kernel driver is mainly for Linux.
                # It can cause issues on macOS and isn't always necessary.
                if not sys.platform.startswith("darwin"):
                    dev.attach_kernel_driver(0)
            except usb.core.USBError:
                # This can also fail if the device is gone or driver was not active.
                pass
            # Finally, dispose of the device handle.
            usb.util.dispose_resources(dev)

def main():
    parser = argparse.ArgumentParser(description="LORE: Edison V3 MicroPython CLI Tool.")
    parser.add_argument("--mpy-cross", 
                        default="./micropython-1.27.0/mpy-cross/build/mpy-cross",
                        help="Path to mpy-cross executable.")
    
    subparsers = parser.add_subparsers(dest="command", help="Available commands")

    build_parser = subparsers.add_parser("build", help="Compile a LOGO or MicroPython application.")
    build_parser.add_argument("app_name", help="Name of the application to compile.")
    build_parser.add_argument("--remote-compile", action="store_true",
                              help="Use remote Edison API compiler instead of local mpy-cross.")

    flash_parser = subparsers.add_parser("flash", help="Flash a compiled application.")
    flash_parser.add_argument("app_name", help="Name of the application to flash.")

    args = parser.parse_args()

    if args.command is None:
        parser.print_help()
        sys.exit(1)

    try:
        if args.command == "build" and args.remote_compile:
            try:
                import requests
            except ImportError:
                raise RuntimeError("'requests' library is required for remote compilation. Run: pip install requests")

        if args.command == "build":
            use_local = not args.remote_compile
            compile_app(args.app_name, args.mpy_cross, use_local)
            print(f"Application '{args.app_name}' built successfully.")
        elif args.command == "flash":
            mpy_file = os.path.join("apps", args.app_name, "main.mpy")
            if not os.path.exists(mpy_file):
                print(f"'{mpy_file}' not found. Building application first...")
                compile_app(args.app_name, args.mpy_cross, False)
            
            flash_app(mpy_file)
            print(f"Application '{args.app_name}' flashed successfully.")
    except Exception as e:
        print(f"Error: {e}", file=sys.stderr)
        sys.exit(1)

if __name__ == "__main__":
    if sys.version_info < (3, 8):
        print("Python 3.8 or newer is required.", file=sys.stderr)
        sys.exit(1)
    main()