#!/usr/bin/env python3
import usb.core
import usb.util
import argparse
import subprocess
import os
import sys
import requests
import json
from lark import Lark, Token, Tree

# EdisonV3 USB constants
RELESE_VENDOR_ID = 0x16D0
RELESE_PRODUCT_ID = 0x1207

EV3_WEBUSB_HEADER = 0x58
EV3_WEBUSB_CMD_PUT_USER_PROGRAM = 0x14

# Remote API URL for compilation
REMOTE_COMPILE_API_URL = "https://api.edisonrobotics.net/ep/compile/ep_compile_usb_v3"

class LogoToEdPyTranspiler:
    """Transpiles a LOGO parse tree (from Lark) to EdPy MicroPython code."""

    def __init__(self, tree):
        self.tree = tree
        self.functions = {}  # name -> (param_names, body_statements)
        self._loop_counter = 0
        self._collect_functions(tree)

    @staticmethod
    def _tokens(node, token_type):
        """Get child tokens of a specific type."""
        return [c for c in node.children if isinstance(c, Token) and c.type == token_type]

    @staticmethod
    def _subtrees(node):
        """Get child Tree nodes."""
        return [c for c in node.children if isinstance(c, Tree)]

    def _collect_functions(self, tree):
        """First pass: collect function definitions with their parameters."""
        for stmt in tree.children:
            node = stmt.children[0]
            if node.data == "funcdef":
                name = str(self._tokens(node, "NAME")[0]).upper()
                params = [str(p)[1:].lower() for p in self._tokens(node, "PARAM")]
                body = self._subtrees(node)
                self.functions[name] = (params, body)

    def generate(self):
        """Generate EdPy Python code from the parse tree."""
        lines = [
            "import Ed",
            "",
            "# Standard EdPy setup",
            "Ed.EdisonVersion = Ed.V3",
            "Ed.DistanceUnits = Ed.CM",
            "Ed.Tempo = Ed.TEMPO_MEDIUM",
            ""
        ]
        # Emit function definitions
        for name, (params, body) in self.functions.items():
            param_str = ", ".join(params)
            lines.append(f"def {name.lower()}({param_str}):")
            for stmt in body:
                lines.extend(self._process_node(stmt.children[0], 1))
            lines.append("")
        # Emit main body
        for stmt in self.tree.children:
            node = stmt.children[0]
            if node.data != "funcdef":
                lines.extend(self._process_node(node, 0))
        return "\n".join(lines)

    def _process_expr(self, node):
        """Process an expression node (Token or Tree) into a Python expression string."""
        if isinstance(node, Token):
            if node.type == "NUMBER":
                return str(int(node))
            elif node.type == "PARAM":
                return str(node)[1:].lower()
        if node.data == "add":
            return f"({self._process_expr(node.children[0])} + {self._process_expr(node.children[1])})"
        elif node.data == "sub":
            return f"({self._process_expr(node.children[0])} - {self._process_expr(node.children[1])})"
        elif node.data == "thing":
            return str(self._tokens(node, "QNAME")[0])[1:].lower()
        return str(node)

    def _process_node(self, node, indent_level):
        """Recursively process a single AST node into code lines."""
        indent = "    " * indent_level
        data = node.data

        if data == "forward":
            expr = self._process_expr(node.children[1])
            return [indent + f"Ed.Drive(Ed.FORWARD, Ed.SPEED_5, {expr})"]
        elif data == "back":
            expr = self._process_expr(node.children[1])
            return [indent + f"Ed.Drive(Ed.BACKWARD, Ed.SPEED_5, {expr})"]
        elif data == "left":
            expr = self._process_expr(node.children[1])
            return [indent + f"Ed.Drive(Ed.SPIN_LEFT, Ed.SPEED_5, {expr})"]
        elif data == "right":
            expr = self._process_expr(node.children[1])
            return [indent + f"Ed.Drive(Ed.SPIN_RIGHT, Ed.SPEED_5, {expr})"]
        elif data == "repeat":
            count = self._process_expr(node.children[1])
            var = f"i{self._loop_counter}"
            self._loop_counter += 1
            lines = [indent + f"for {var} in range({count}):"]
            for child_stmt in self._subtrees(node):
                lines.extend(self._process_node(child_stmt.children[0], indent_level + 1))
            return lines
        elif data == "ifstmt":
            comp = self._subtrees(node)[0]  # comparison node
            left = self._process_expr(comp.children[0])
            op = str(self._tokens(comp, "COMP_OP")[0])
            if op == "=":
                op = "=="
            right = self._process_expr(comp.children[2])
            lines = [indent + f"if {left} {op} {right}:"]
            for child_stmt in self._subtrees(node)[1:]:
                lines.extend(self._process_node(child_stmt.children[0], indent_level + 1))
            return lines
        elif data == "ifelsestmt":
            subtrees = self._subtrees(node)
            comp = subtrees[0]  # comparison node
            left = self._process_expr(comp.children[0])
            op = str(self._tokens(comp, "COMP_OP")[0])
            if op == "=":
                op = "=="
            right = self._process_expr(comp.children[2])
            true_branch = [s for s in subtrees if s.data == "truebranch"][0]
            false_branch = [s for s in subtrees if s.data == "falsebranch"][0]
            lines = [indent + f"if {left} {op} {right}:"]
            for child_stmt in self._subtrees(true_branch):
                lines.extend(self._process_node(child_stmt.children[0], indent_level + 1))
            lines.append(indent + "else:")
            for child_stmt in self._subtrees(false_branch):
                lines.extend(self._process_node(child_stmt.children[0], indent_level + 1))
            return lines
        elif data == "make":
            varname = str(self._tokens(node, "QNAME")[0])[1:].lower()
            # The expr is the last non-keyword child
            expr_children = [c for c in node.children if not (isinstance(c, Token) and c.type in ("MAKE", "QNAME"))]
            expr = self._process_expr(expr_children[0])
            return [indent + f"{varname} = {expr}"]
        elif data == "funccall":
            name = str(self._tokens(node, "NAME")[0]).upper()
            if name not in self.functions:
                print(f"Warning: Unknown function '{name}'. Skipping.", file=sys.stderr)
                return []
            # Build argument list from expr children
            expr_children = [c for c in node.children if not (isinstance(c, Token) and c.type == "NAME")]
            args = [self._process_expr(e) for e in expr_children]
            args_str = ", ".join(args)
            return [indent + f"{name.lower()}({args_str})"]
        else:
            print(f"Warning: Unsupported node type '{data}'. Skipping.", file=sys.stderr)
            return []


def transpile_logo_to_py(logo_file_path: str, py_file_path: str):
    """
    Transpiles a .logo file to an EdPy .py file using a Lark grammar parser.
    """
    print(f"Transpiling {logo_file_path} to {py_file_path}...")

    grammar_path = os.path.join(os.path.dirname(os.path.abspath(__file__)), "logo.lark")
    with open(grammar_path, 'r') as f:
        grammar = f.read()
    with open(logo_file_path, 'r') as f:
        source = f.read()

    parser = Lark(grammar, parser="lalr")
    tree = parser.parse(source)

    transpiler = LogoToEdPyTranspiler(tree)
    code = transpiler.generate()

    with open(py_file_path, 'w') as f:
        f.write(code)

    print("Transpilation successful.")


def process_api_hex_string(input_hex_str):
    """
    Converts a hexadecimal string into a bytearray.
    """
    prog_size = len(input_hex_str) // 2
    user_prog_data = bytearray(prog_size)
    
    for i in range(0, len(input_hex_str), 2):
        num_string = "0x" + input_hex_str[i:i+2]
        num_data = int(num_string, 16)
        user_prog_data[i // 2] = num_data
        
    if prog_size > 2048:
        print("Warning: Program size exceeds 2048 bytes.", file=sys.stderr)
    
    return user_prog_data

def calculate_checksum(data: bytearray) -> int:
    """
    Calculates the 16-bit XOR checksum.
    """
    checksum = 0
    lower_byte = True
    for byte_val in data:
        if lower_byte:
            checksum ^= byte_val
            lower_byte = False
        else:
            checksum ^= (byte_val << 8)
            lower_byte = True
    return checksum & 0xFFFF

def find_edison_v3():
    """Finds the Edison V3 device."""
    dev = usb.core.find(idVendor=RELESE_VENDOR_ID, idProduct=RELESE_PRODUCT_ID)
    if dev is None:
        raise ValueError("Edison V3 not found.")
    return dev

def setup_device(dev):
    """Configures the USB device for communication."""
    try:
        dev.set_configuration()
    except usb.core.USBError as e:
        if "Access denied" in str(e):
            print("Error: Access denied to USB device. Try with sudo.", file=sys.stderr)
            sys.exit(1)
        raise

    for cfg in dev:
        for intf in cfg:
            if dev.is_kernel_driver_active(intf.bInterfaceNumber):
                try:
                    dev.detach_kernel_driver(intf.bInterfaceNumber)
                except usb.core.USBError as e:
                    print(f"Warning: Could not detach kernel driver: {e}", file=sys.stderr)
    
    usb.util.claim_interface(dev, 0)
    return dev

def transfer_out(dev, endpoint_address, data):
    """Performs a USB bulk transfer out."""
    return dev.write(endpoint_address, data)

def transfer_in(dev, endpoint_address, length):
    """Performs a USB bulk transfer in."""
    return dev.read(endpoint_address, length)

def put_user_program(dev, user_program_data: bytearray):
    """Sends the user program to the Edison V3."""
    size = len(user_program_data)
    checksum = calculate_checksum(user_program_data)

    header = bytearray([
        EV3_WEBUSB_HEADER,
        EV3_WEBUSB_CMD_PUT_USER_PROGRAM,
        size & 0xFF, (size >> 8) & 0xFF,
        checksum & 0xFF, (checksum >> 8) & 0xFF,
        0, 0
    ])

    transfer_out(dev, 0x01, header)
    response = transfer_in(dev, 0x81, 8)
    if not (len(response) == 8 and response[0] == EV3_WEBUSB_HEADER and response[1] == EV3_WEBUSB_CMD_PUT_USER_PROGRAM):
        raise IOError(f"Invalid response to program header: {response.tobytes().hex()}")
    
    transfer_out(dev, 0x01, user_program_data)
    response = transfer_in(dev, 0x81, 8)
    if not (len(response) == 8 and response[0] == EV3_WEBUSB_HEADER and response[1] == EV3_WEBUSB_CMD_PUT_USER_PROGRAM and response[2] == 1):
        raise IOError(f"Program transfer failed with response: {response.tobytes().hex()}")
    
    print("Program transferred successfully!")

def build_mpy_cross(mpy_cross_path: str):
    """Builds the mpy-cross executable if it doesn't exist."""
    if not os.path.exists(mpy_cross_path):
        print("mpy-cross not found, building with 'make'...")
        try:
            subprocess.run(["make"], check=True)
            print("'make' completed successfully.")
        except (subprocess.CalledProcessError, FileNotFoundError) as e:
            raise RuntimeError(f"Error: 'make' failed.", e)

def compile_remotely(py_file_path: str, output_mpy_file: str):
    """
    Compiles a Python file using the remote Edison API.
    """
    try:
        with open(py_file_path, 'r') as f:
            python_code = f.read()
        
        print(f"Sending to remote compiler API...")
        response = requests.post(REMOTE_COMPILE_API_URL, data=python_code, headers={'Content-Type': 'text/plain'})
        response.raise_for_status()
        
        json_response = response.json()
        
        if json_response.get("error") or not json_response.get("compile", True):
            error_message = "Unknown remote compilation error."
            nested_message = json_response.get("message")
            if nested_message:
                try:
                    nested_json = json.loads(nested_message)
                    if nested_json.get("error") and nested_json.get("messages"):
                        error_message = "; ".join(nested_json["messages"])
                except json.JSONDecodeError:
                    error_message = nested_message
            raise RuntimeError(f"Remote compilation error: {error_message}")
        
        hex_data = json_response.get("hex")
        if not hex_data:
            raise RuntimeError("Remote compiler did not return 'hex' data.")
            
        compiled_bytes = bytes.fromhex(hex_data)
        
        with open(output_mpy_file, 'wb') as f:
            f.write(compiled_bytes)
            
        print(f"Remote compilation successful.")
        
    except requests.exceptions.RequestException as e:
        raise RuntimeError(f"Failed to connect to remote compiler API: {e}")
    except ValueError as e:
        raise RuntimeError(f"Error processing remote compiler response: {e}")

def compile_app(app_name: str, mpy_cross_path: str, use_local_compiler: bool) -> str:
    """
    Detects if an app is LOGO or Python, transpiles if needed, then compiles to .mpy.
    """
    app_dir = os.path.join("apps", app_name)
    py_file_path = os.path.join(app_dir, "main.py")
    logo_file_path = os.path.join(app_dir, "main.logo")

    if os.path.exists(logo_file_path):
        transpile_logo_to_py(logo_file_path, py_file_path)
    elif not os.path.exists(py_file_path):
        raise FileNotFoundError(f"Application source not found in {app_dir}")
    
    output_mpy_file = os.path.join(app_dir, "main.mpy")

    if use_local_compiler:
        build_mpy_cross(mpy_cross_path)
        print(f"Compiling with local {mpy_cross_path}...")
        result = subprocess.run(
            [mpy_cross_path, "-s", "main.py", "-o", output_mpy_file, py_file_path],
            capture_output=True, text=True
        )
        if result.returncode != 0:
            raise RuntimeError(f"Local compilation failed:\n{result.stderr.strip()}")
        print("Local compilation successful.")
    else:
        compile_remotely(py_file_path, output_mpy_file)

    return output_mpy_file

def flash_app(mpy_file_path: str):
    """
    Flashes a pre-compiled .mpy file to the Edison V3.
    """
    if not os.path.exists(mpy_file_path):
        raise FileNotFoundError(f"Compiled file not found: {mpy_file_path}. Please build first.")

    with open(mpy_file_path, 'rb') as f:
        mpy_bytes = f.read()
    
    program_data_to_send = process_api_hex_string(mpy_bytes.hex())

    dev = find_edison_v3()
    setup_device(dev)
    
    try:
        put_user_program(dev, program_data_to_send)
    finally:
        try:
            usb.util.release_interface(dev, 0)
        except usb.core.USBError as e:
            print(f"Warning: Could not release interface: {e}", file=sys.stderr)
        try:
            dev.attach_kernel_driver(0)
        except usb.core.USBError as e:
            if "No such device" not in str(e):
                print(f"Warning: Could not re-attach kernel driver: {e}", file=sys.stderr)
        usb.util.dispose_resources(dev)

def main():
    parser = argparse.ArgumentParser(description="Lore: Edison V3 MicroPython CLI Tool.")
    parser.add_argument("--mpy-cross", 
                        default="./micropython-1.27.0/mpy-cross/build/mpy-cross",
                        help="Path to mpy-cross executable.")
    
    subparsers = parser.add_subparsers(dest="command", help="Available commands")

    build_parser = subparsers.add_parser("build", help="Compile a LOGO or MicroPython application.")
    build_parser.add_argument("app_name", help="Name of the application to compile.")
    build_parser.add_argument("--local-compile", action="store_true",
                              help="Use local mpy-cross compiler instead of remote API.")

    flash_parser = subparsers.add_parser("flash", help="Flash a compiled application.")
    flash_parser.add_argument("app_name", help="Name of the application to flash.")

    args = parser.parse_args()

    if args.command is None:
        parser.print_help()
        sys.exit(1)

    try:
        if args.command == "build" and not args.local_compile:
            try:
                import requests
            except ImportError:
                raise RuntimeError("'requests' library is required for remote compilation. Run: pip install requests")

        if args.command == "build":
            compile_app(args.app_name, args.mpy_cross, args.local_compile)
            print(f"Application '{args.app_name}' built successfully.")
        elif args.command == "flash":
            mpy_file = os.path.join("apps", args.app_name, "main.mpy")
            if not os.path.exists(mpy_file):
                print(f"'{mpy_file}' not found. Building application first...")
                compile_app(args.app_name, args.mpy_cross, False)
            
            flash_app(mpy_file)
            print(f"Application '{args.app_name}' flashed successfully.")
    except Exception as e:
        print(f"Error: {e}", file=sys.stderr)
        sys.exit(1)

if __name__ == "__main__":
    if sys.version_info < (3, 8):
        print("Python 3.8 or newer is required.", file=sys.stderr)
        sys.exit(1)
    main()